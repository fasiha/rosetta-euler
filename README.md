# Rosetta Stone: Project Euler

~~~js
var tape = require("tape");
~~~

## Problem 1
> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

### JavaScript
~~~js
function simpleRange(n) { return Array.from(Array(n), (_, i) => i); }
function sum(v) { return v.reduce((prev, curr) => prev + curr, 0); }
function euler1(max = 1000) {
  return sum(range(max).filter(x => x % 3 === 0 || x % 5 === 0));
}
var t = tape("Problem 1", test => {
  test.equal(euler1(10), 23);
  test.end();
});
t.run()
console.log(`Problem 1: ${euler1(1000)}`);
~~~

### Matlab/Octave
Matlab doesnâ€™t allow you to define functions inside a single file, but Octave does, bless its cottonsocks!
~~~matlab
% Octave âœ…. Matlab youâ€™ll have to save the function in a file, `euler1.m`.
function solution = euler1(Nmax)
  n = 1 : (Nmax - 1); % colon range operator is inclusive
  solution = sum(n(mod(n, 3) == 0 | mod(n, 5) == 0));
end

disp(euler1(1000));
~~~

### Elm
Ok! Now for some fun.

~~~elm
-- to Euler1.elm
import Html exposing (text)
import List

euler1 nmax =
  (List.range 1 (nmax - 1))
    |> List.filter (\n -> n % 3 == 0 || n % 5 == 0)
    |> List.sum

main =
  text (toString (euler1 1000))
~~~

## Problem 2
> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> > 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

### Elm
~~~elm
import Html exposing (text)
import List
import Arithmetic

fibsAppendNext listSoFar =
  List.sum (List.take 2 listSoFar) :: listSoFar


fibsTilWorker max listSoFar =
  if (Maybe.withDefault 0 (List.head listSoFar)) > max
    then List.drop 1 listSoFar
    else fibsTilWorker max (fibsAppendNext listSoFar)


fibsTil max =
  fibsTilWorker max [2, 1]


euler2 n =
  fibsTil n
    |> List.filter Arithmetic.isEven
    |> List.sum


main =
  text (toString euler2 4000000)
~~~
### JS
Having too much fun with Elm to stop to make other implementations.

## Problem 3
> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143 ?

### Matlab
~~~matlab
disp(max(factor(600851475143)))
~~~

### Elm
Alas, the `Arithemetic` libraryâ€™s prime factorizer fails for numbers bigger than the largest 32-bit number, so this wonâ€™t work:
~~~elm
import Html exposing (text)
import List
import Arithmetic

euler3 n =
  Arithmetic.primeFactors n
    |> List.maximum

main =
  text (toString (euler3 600851475143))
~~~
But I donâ€™t really want to implement my own primal sieve either:
~~~elm
maxPrimeFactorWorker target sofar =
  if floatMod0 target sofar
    then sofar
    else maxPrimeFactorWorker target (sofar - 1)


maxPrimeFactor n =
  maxPrimeFactorWorker n (floorFloat (n / 2))


floorFloat n =
  toFloat (floor n)


floatMod0 num den =
  (num / den) == (toFloat (floor (num / den)))
~~~
With this, `maxPrimeFactor 123456789` works, but must be very slow because the original problem is too big.

I have to contort myself:

- I have to manually control for integer vs floating-point. This could be hugely burdensome.
- `floor : Float -> Int` and thereâ€™s no to-float version. There should be.
- Mod and rem operate only on integers. ðŸ˜³ðŸ™„ðŸ˜–.

## Problem 4
> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

### Matlab
~~~matlab
isPalindrome = @(s) strcmp(s, fliplr(s))

mat = [100 : 999]' * [100 : 999];
vec = unique(mat(:));

for i = fliplr(vec')
  if isPalindrome(sprintf('%d', i))
    result = i;
    break;
  end
end
~~~
Again here I miss a â€œreduce from right but end earlyâ€ function like Clojure has. Well, recursion.

Oopsâ€”only when I looked at the (prime) `factor`s of the `result` did I realize that the question asked for palindrome products of two *three-digit* numbers. Luckily, the answer is the same. (I did a double-take because only one *prime* factor has three digits, but the product of two smaller ones yielded another tridigiter.)

## Unused code
~~~js
// Via http://stackoverflow.com/a/39930823/500207
function range(start, stop, step = 1) {
  if (typeof start === 'undefined') {
    throw new TypeError('At least one argument required');
  }
  if (typeof stop === 'undefined') {
    stop = start;
    start = 0;
  }
  if ((start > stop && step > 0) || (start < stop && step < 0) || step === 0) {
    return [];
  }
  return Array.from(new Array(Math.ceil((stop - start) / step)),
                    (_, i) => start + i * step);
}
~~~

~~~js
var t = tape("improper steps yield empty matrix", test => {
  test.equal(range(-10).length, 0);
  test.equal(range(0, -10).length, 0);
  test.equal(range(0, 5, -1).length, 0);
  test.end();
});
t.run();

var t = tape("no arguments throws", test => {
  test.throws(() => range(), /one argument required/);
  test.end();
});
t.run();

var t = tape("regular operation", test => {
  test.deepEqual(range(4), [0, 1, 2, 3]);
  test.deepEqual(range(-2, 2), [-2, -1, 0, 1]);
  test.deepEqual(range(-2, 2, 2), [-2, 0]);
  test.deepEqual(range(2, -2, -2), [2, 0]);
  // Floats are imperfect but should work barring pathological cases
  test.deepEqual(range(-1, 1, 0.5), [-1, -.5, 0, .5]);
  test.deepEqual(range(1, -1, -0.5), [1, .5, 0, -.5]);
  // A huge step should just return the initial
  test.deepEqual(range(0, 5, 100), [0]);
  test.end();
});
t.run();
~~~

asd
